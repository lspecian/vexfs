# Kbuild file for VexFS kernel module

# The final module will be named vexfs.ko
obj-m += vexfs.o

# Name of the C object file compiled from vexfs_module_entry.c
VEXFS_C_OBJ := vexfs_module_entry.o

# Specify the objects that make up vexfs.o
# We only include the C object here, and link the Rust library via LDFLAGS
vexfs-objs := $(VEXFS_C_OBJ)

# Add the Rust static library to the link flags using absolute path
EXTRA_LDFLAGS += $(src)/libvexfs.a

# Optional: If there are C header files specific to this module in an 'include' directory
# ccflags-y += -I$(src)/include

# This Kbuild setup expects:
# 1. vexfs_module_entry.c to be present in $(src) (current directory).
#    Kbuild will compile it to vexfs_module_entry.o.
# 2. $(VEXFS_RUST_LIB_FILENAME) (e.g., libvexfs.a) to be present in $(src).
#    The main Makefile is responsible for building this with cargo
#    and copying it here before invoking the kernel build.

# To ensure the linker finds the Rust standard libraries (core, alloc, etc.)
# and any other crates that libvexfs.a depends on, the RUSTFLAGS or linker
# arguments might need to be adjusted in the main Makefile when cargo build
# is invoked, or by passing appropriate LDFLAGS to the kernel's `make` command.
# However, for a static library `libfoo.a`, the symbols it needs should ideally
# be self-contained or resolved from other libraries provided to the linker.
# The `rust-kernel-rdma` example uses `cargo rustc ... -- -C link-arg=...`
# This is handled by cargo when building libvexfs.a as a staticlib.
# The kernel linker just needs to link libvexfs.a itself.

# No specific clean actions needed here beyond what `make clean` in kernel dir does for .o files.
# The main Makefile handles `cargo clean`.
